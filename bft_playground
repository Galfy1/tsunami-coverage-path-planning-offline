from collections import deque as queue
import numpy as np


# BASED ON https://www.geeksforgeeks.org/dsa/breadth-first-traversal-bfs-on-a-2d-array/

# TODO DER ER ET FUNDEMENTALT ISSUE HER... BFS ER POITNSE IKKE NØDVENDLIGVIS VED SIDEN AF HINANDEN
    # I DERES PAPER: er hver point ved siden af hidnanden fordi dronen vælger de points der er tættest på

# Direction vectors
dRow = [ -1, 0, 1, 0]
dCol = [ 0, 1, 0, -1]


# Function to check if a cell
# is be visited or not
def is_valid(grid, vis, x, y):
  
    # If cell lies out of bounds
    if (x < 0 or y < 0 or x >= grid.shape[0] or y >= grid.shape[1]):
        return False

    # If cell is already visited
    if (vis[x][y]):
        return False
    
    # If cell is not traversable (i.e. "no fly zone")
    if (grid[x][y] == 0):
        return False

    # Otherwise
    return True

# Function to perform the BFS traversal
# grid: 2D numpy array where 1 = flyable, 0 = no-fly zone
# start_row, start_col: starting coordinates for the BFS
def breadth_first_traversal(grid, start_row, start_col):

    # Error check
    if (grid[start_row][start_col] == 0):
        raise ValueError("Starting point must be within the polygon and outside no-fly zones")

    # Declare the BFS result and visited array
    result = np.full((grid.shape[0], grid.shape[1]), float('inf'))
    vis = np.full((grid.shape[0], grid.shape[1]), False)

    # Distance value for the BFS
    distance_value = 0

    # Stores indices of the matrix cells
    q = queue()

    # Mark the starting cell as visited, set its distance value and push it into the queue
    vis[start_row][start_col] = True
    result[start_row][start_col] = distance_value
    q.append(( start_row, start_col ))


    # Iterate while the queue
    # is not empty
    while (len(q) > 0):
        cell = q.popleft()
        x = cell[0]
        y = cell[1]
        #print(grid[x][y], end = " ")
        #result.append((x, y))

        #q.pop()

        distance_value += 1

        # Go to the adjacent cells (not diagonal)
        for i in range(4):
            adjx = x + dRow[i]
            adjy = y + dCol[i]
            if (is_valid(grid, vis, adjx, adjy)):
                q.append((adjx, adjy))
                result[adjx][adjy] = distance_value
                vis[adjx][adjy] = True

    return result


def traversel_order(grid, start_row, start_col):
    bft = breadth_first_traversal(grid, start_row, start_col)


# Test Code
if __name__ == '__main__':
  
    # Given input matrix
    grid = np.array([[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                    [0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                    [0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
                    [0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1],
                    [0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1],
                    [0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1],
                    [0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1],
                    [0,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1]])



    # vis, False, sizeof vis)

    print(breadth_first_traversal(grid, 10, 10))